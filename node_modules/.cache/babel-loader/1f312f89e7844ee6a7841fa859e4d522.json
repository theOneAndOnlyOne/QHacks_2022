{"ast":null,"code":"import{Children,cloneElement,isValidElement}from'react';/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */export function getChildMapping(children,mapFn){var mapper=function mapper(child){return mapFn&&/*#__PURE__*/isValidElement(child)?mapFn(child):child;};var result=Object.create(null);if(children)Children.map(children,function(c){return c;}).forEach(function(child){// run the map function here instead so that the key is the computed one\nresult[child.key]=mapper(child);});return result;}/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */export function mergeChildMappings(prev,next){prev=prev||{};next=next||{};function getValueForKey(key){return key in next?next[key]:prev[key];}// For each key of `next`, the list of keys to insert before that key in\n// the combined list\nvar nextKeysPending=Object.create(null);var pendingKeys=[];for(var prevKey in prev){if(prevKey in next){if(pendingKeys.length){nextKeysPending[prevKey]=pendingKeys;pendingKeys=[];}}else{pendingKeys.push(prevKey);}}var i;var childMapping={};for(var nextKey in next){if(nextKeysPending[nextKey]){for(i=0;i<nextKeysPending[nextKey].length;i++){var pendingNextKey=nextKeysPending[nextKey][i];childMapping[nextKeysPending[nextKey][i]]=getValueForKey(pendingNextKey);}}childMapping[nextKey]=getValueForKey(nextKey);}// Finally, add the keys which didn't appear before any key in `next`\nfor(i=0;i<pendingKeys.length;i++){childMapping[pendingKeys[i]]=getValueForKey(pendingKeys[i]);}return childMapping;}function getProp(child,prop,props){return props[prop]!=null?props[prop]:child.props[prop];}export function getInitialChildMapping(props,onExited){return getChildMapping(props.children,function(child){return/*#__PURE__*/cloneElement(child,{onExited:onExited.bind(null,child),in:true,appear:getProp(child,'appear',props),enter:getProp(child,'enter',props),exit:getProp(child,'exit',props)});});}export function getNextChildMapping(nextProps,prevChildMapping,onExited){var nextChildMapping=getChildMapping(nextProps.children);var children=mergeChildMappings(prevChildMapping,nextChildMapping);Object.keys(children).forEach(function(key){var child=children[key];if(!/*#__PURE__*/isValidElement(child))return;var hasPrev=(key in prevChildMapping);var hasNext=(key in nextChildMapping);var prevChild=prevChildMapping[key];var isLeaving=/*#__PURE__*/isValidElement(prevChild)&&!prevChild.props.in;// item is new (entering)\nif(hasNext&&(!hasPrev||isLeaving)){// console.log('entering', key)\nchildren[key]=/*#__PURE__*/cloneElement(child,{onExited:onExited.bind(null,child),in:true,exit:getProp(child,'exit',nextProps),enter:getProp(child,'enter',nextProps)});}else if(!hasNext&&hasPrev&&!isLeaving){// item is old (exiting)\n// console.log('leaving', key)\nchildren[key]=/*#__PURE__*/cloneElement(child,{in:false});}else if(hasNext&&hasPrev&&/*#__PURE__*/isValidElement(prevChild)){// item hasn't changed transition states\n// copy over the last transition props;\n// console.log('unchanged', key)\nchildren[key]=/*#__PURE__*/cloneElement(child,{onExited:onExited.bind(null,child),in:prevChild.props.in,exit:getProp(child,'exit',nextProps),enter:getProp(child,'enter',nextProps)});}});return children;}","map":{"version":3,"sources":["C:/Users/joshu/Test/src/node_modules/react-transition-group/esm/utils/ChildMapping.js"],"names":["Children","cloneElement","isValidElement","getChildMapping","children","mapFn","mapper","child","result","Object","create","map","c","forEach","key","mergeChildMappings","prev","next","getValueForKey","nextKeysPending","pendingKeys","prevKey","length","push","i","childMapping","nextKey","pendingNextKey","getProp","prop","props","getInitialChildMapping","onExited","bind","in","appear","enter","exit","getNextChildMapping","nextProps","prevChildMapping","nextChildMapping","keys","hasPrev","hasNext","prevChild","isLeaving"],"mappings":"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","sourcesContent":["import { Children, cloneElement, isValidElement } from 'react';\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\n\nexport function getChildMapping(children, mapFn) {\n  var mapper = function mapper(child) {\n    return mapFn && isValidElement(child) ? mapFn(child) : child;\n  };\n\n  var result = Object.create(null);\n  if (children) Children.map(children, function (c) {\n    return c;\n  }).forEach(function (child) {\n    // run the map function here instead so that the key is the computed one\n    result[child.key] = mapper(child);\n  });\n  return result;\n}\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\n\nexport function mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  function getValueForKey(key) {\n    return key in next ? next[key] : prev[key];\n  } // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n\n  var nextKeysPending = Object.create(null);\n  var pendingKeys = [];\n\n  for (var prevKey in prev) {\n    if (prevKey in next) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var i;\n  var childMapping = {};\n\n  for (var nextKey in next) {\n    if (nextKeysPending[nextKey]) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n\nfunction getProp(child, prop, props) {\n  return props[prop] != null ? props[prop] : child.props[prop];\n}\n\nexport function getInitialChildMapping(props, onExited) {\n  return getChildMapping(props.children, function (child) {\n    return cloneElement(child, {\n      onExited: onExited.bind(null, child),\n      in: true,\n      appear: getProp(child, 'appear', props),\n      enter: getProp(child, 'enter', props),\n      exit: getProp(child, 'exit', props)\n    });\n  });\n}\nexport function getNextChildMapping(nextProps, prevChildMapping, onExited) {\n  var nextChildMapping = getChildMapping(nextProps.children);\n  var children = mergeChildMappings(prevChildMapping, nextChildMapping);\n  Object.keys(children).forEach(function (key) {\n    var child = children[key];\n    if (!isValidElement(child)) return;\n    var hasPrev = (key in prevChildMapping);\n    var hasNext = (key in nextChildMapping);\n    var prevChild = prevChildMapping[key];\n    var isLeaving = isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)\n\n    if (hasNext && (!hasPrev || isLeaving)) {\n      // console.log('entering', key)\n      children[key] = cloneElement(child, {\n        onExited: onExited.bind(null, child),\n        in: true,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    } else if (!hasNext && hasPrev && !isLeaving) {\n      // item is old (exiting)\n      // console.log('leaving', key)\n      children[key] = cloneElement(child, {\n        in: false\n      });\n    } else if (hasNext && hasPrev && isValidElement(prevChild)) {\n      // item hasn't changed transition states\n      // copy over the last transition props;\n      // console.log('unchanged', key)\n      children[key] = cloneElement(child, {\n        onExited: onExited.bind(null, child),\n        in: prevChild.props.in,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    }\n  });\n  return children;\n}"]},"metadata":{},"sourceType":"module"}